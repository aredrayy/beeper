import appuifw
import e32
import urllib
import sys
import btsocket
import socket
import random
import thread
import time

# --- CONFIGURATION ---
# Update this link if the tunnel changes!
SERVER_URL = "http://6adb761713c87b.lhr.life"
TARGET_AP_NAME = u"DIGI" 

# Global objects
lock = e32.Ao_lock()
timer = e32.Ao_timer()
seen_ids = []
view_mode = 'list'
loop_counter = 0
apo = None
keep_alive_running = False

def safe_u(s):
    try:
        if isinstance(s, unicode): return s
        return str(s).decode('utf-8', 'ignore')
    except:
        return u"?"

# --- NETWORK HELPER ---
def fetch_url(url_endpoint):
    full_url = SERVER_URL + url_endpoint
    # Add random junk to force a fresh request (no caching)
    if "?" in full_url: full_url += "&r=" + str(random.random())
    else: full_url += "?r=" + str(random.random())
    
    # We use the existing connection
    f = urllib.urlopen(full_url)
    data = f.read()
    f.close()
    return data

# --- THE HEARTBEAT (Fixes the Popup Issue) ---
def keep_alive_worker():
    global keep_alive_running
    while keep_alive_running:
        try:
            # We create a dummy socket connection to the server port 80
            # This forces the Symbian OS to keep the 3G/WiFi interface ACTIVE.
            # We don't even need to send data, just connecting is enough.
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            # Parse the domain from your SERVER_URL (remove http://)
            domain = SERVER_URL.replace("http://", "").replace("/", "")
            s.settimeout(5)
            s.connect((domain, 80))
            s.close()
            # Sleep less than the Symbian timeout (usually 10-20s)
            time.sleep(5) 
        except:
            # If it fails, wait a bit and try again. Don't crash.
            time.sleep(5)

def start_keep_alive():
    global keep_alive_running
    if not keep_alive_running:
        keep_alive_running = True
        thread.start_new_thread(keep_alive_worker, ())

# --- CONNECTION SETUP ---
def connect_to_ap():
    global apo
    socket.setdefaulttimeout(60)
    
    found_apid = None
    all_aps = socket.access_points()
    for ap in all_aps:
        if ap['name'] == TARGET_AP_NAME:
            found_apid = ap['id']
            break
    
    if found_apid:
        apid = found_apid
    else:
        appuifw.note(u"AP not found! Select manually.", "conf")
        apid = btsocket.select_access_point()
    
    # Initialize the connection object ONCE
    apo = btsocket.access_point(apid) 
    btsocket.set_default_access_point(apo) 
    apo.start() 
    
    # Start the heartbeat to lock it open
    start_keep_alive()
    
    appuifw.note(u"Connected & Locked", "conf")

# Initial Connection
try:
    connect_to_ap()
except Exception, e:
    appuifw.note(u"Net: " + str(e), "error")

def exit_app():
    global keep_alive_running
    keep_alive_running = False
    timer.cancel()
    try: apo.stop()
    except: pass
    lock.signal()

appuifw.app.exit_key_handler = exit_app
appuifw.app.title = u"Beeper N95"

# --- VIEW 1: CHAT LIST ---
def show_chat_list():
    global chat_data_list, view_mode
    view_mode = 'list'
    timer.cancel()
    appuifw.note(u"Loading...", "info")
    try:
        raw = fetch_url("/get_chat_list")
        chat_data_list = eval(raw, {"true":True, "false":False, "null":None})
        
        ui_list = []
        for c in chat_data_list:
            ui_list.append(u"%s (%s)" % (safe_u(c[0]), safe_u(c[2])))
            
        lb = appuifw.Listbox(ui_list, on_select_chat)
        appuifw.app.body = lb
        appuifw.app.menu = [(u"Refresh", show_chat_list), (u"Exit", exit_app)]
    except Exception, e:
        appuifw.note(u"List Err: " + str(e), "error")

def on_select_chat():
    try:
        index = appuifw.app.body.current()
        chat_id = chat_data_list[index][1]
        name = safe_u(chat_data_list[index][0])
        
        appuifw.note(u"Opening...", "info")
        if isinstance(chat_id, unicode): chat_id = chat_id.encode('utf-8')
        
        # Request 20 messages to fill the screen
        params = urllib.urlencode({'id': chat_id, 'limit': 20})
        f = urllib.urlopen(SERVER_URL + "/select_chat", params)
        f.read()
        f.close()
        
        show_chat_view(name)
    except Exception, e:
        appuifw.note(u"Open Err: " + str(e), "error")

# --- VIEW 2: CONVERSATION ---
def show_chat_view(name):
    global seen_ids, view_mode, loop_counter
    view_mode = 'chat'
    loop_counter = 0
    seen_ids = [] 
    
    log_box = appuifw.Text()
    appuifw.app.body = log_box
    appuifw.app.title = name
    appuifw.app.menu = [
        (u"Send", send_msg_ui),
        (u"Refresh", force_refresh),
        (u"Back", show_chat_list)
    ]
    fetch_loop()

def force_refresh():
    timer.cancel()
    fetch_loop()

def fetch_loop():
    global seen_ids, loop_counter
    if view_mode != 'chat': return

    loop_counter += 1
    if loop_counter > 5: loop_counter = 0
    appuifw.app.title = u"Chat %s" % ("." * loop_counter)

    try:
        data = fetch_url("/get_messages")
        messages = eval(data, {"true":True, "false":False, "null":None})
        
        # FIX 2: REVERSE MESSAGES
        # If the server sends [Newest, ..., Oldest], we need to reverse
        # it so the conversation reads correctly from top to bottom.
        # Try this. If chats look upside down, delete this line.
        messages.reverse()

        new_activity = False
        
        for m in messages:
            if 'id' not in m: continue
            msg_id = m['id']
            
            if msg_id not in seen_ids:
                seen_ids.append(msg_id)
                if len(seen_ids) > 100: seen_ids.pop(0)

                sender = safe_u(m['sender'])
                txt = safe_u(m['msg'])
                
                if sender == u"Me":
                    appuifw.app.body.add(u">> %s\n" % txt)
                else:
                    appuifw.app.body.add(u"%s: %s\n" % (sender, txt))
                    new_activity = True

        if new_activity:
            e32.ao_yield() # Update screen immediately
            appuifw.app.body.set_pos(appuifw.app.body.len())

    except:
        pass
    
    finally:
        timer.cancel()
        timer.after(4, fetch_loop)

def send_msg_ui():
    msg = appuifw.query(u"Msg:", "text")
    if msg:
        try:
            params = urllib.urlencode({'msg': msg.encode('utf-8')})
            urllib.urlopen(SERVER_URL + "/send", params).close()
            timer.after(1, force_refresh)
        except:
            appuifw.note(u"Send Err", "error")

show_chat_list()
lock.wait()